package dal.concrete.mysql;

import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.sql.Timestamp;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;

import dal.annotations.Column;
import dal.annotations.DBCollection;
import dal.annotations.ForeignKey;
import dal.annotations.Polymorphic;
import dal.annotations.Storeable;
import dal.connection.ConnectionManager;

public abstract class AbstractDAO<T> {

	private Class<?> className;
	
	public AbstractDAO(Class<?> klass) {
		className = klass;
	}
	
	public String getTableName() {
		return className.getAnnotation(Storeable.class).tableName();
	}
	
	private String createAttributesString() {
		StringBuilder builder = new StringBuilder();
		
		builder.append("(");
		
		String prefix = "";
		for (Field field: className.getFields()) {	
			Column col = field.getAnnotation(Column.class);
			
			if (col != null) {
				if (col.autoGenerated())
					continue;
				
				builder.append(prefix);
				prefix = ", ";
				builder.append(col.columnName());
			}
		}
		
		builder.append(")");
		
		return builder.toString();
	}

	
	private String createStringToAdd(T object) {
		StringBuilder builder = new StringBuilder();
		
		builder.append("(");
		
		String prefix = "";
		for (Field field: className.getFields()) {			
			Column col = field.getAnnotation(Column.class);
						
			if (col != null) {
				if (col.autoGenerated())
					continue;
				
				try {
					builder.append(prefix);
					prefix = ", ";
					
					Object obj = field.get(object);
					
					if (field.getType() == String.class || field.getType() == Timestamp.class)
						builder.append("'");
					
					builder.append(obj);
					
					if (field.getType() == String.class || field.getType() == Timestamp.class)
						builder.append("'");
					
				} catch (IllegalArgumentException e) {
					e.printStackTrace();
				} catch (IllegalAccessException e) {
					e.printStackTrace();
				}
			}
		}
		
		builder.append(")");
		
		return builder.toString();
	}
	
	public void loadRelationships(T object) {
		loadOneRelationships(object);
		loadManyRelationships(object);
		loadPolymorphicRelationShips(object);
	}

	private void loadPolymorphicRelationShips(T object) {
		for (Field field: className.getFields()) {			
			Polymorphic pol = field.getAnnotation(Polymorphic.class);
						
			if (pol != null) {				
				try {				
					HashMap<String, Object> search = new HashMap<String, Object>();
					
					for (int i = 0; i < pol.fk().thisSideAttrs().length; i++) {					
						Field fieldThis = object.getClass().getDeclaredField(pol.fk().thisSideAttrs()[i]);
						
						fieldThis.setAccessible(true);
						Object value = fieldThis.get(object);
						fieldThis.setAccessible(false);
						
						search.put(pol.fk().otherSideAttrs()[i], value);
					}
					
					String otherTable = (String) className.getField(pol.tableAttr()).get(object);
									
					Class<?> klass = Class.forName("dal.concrete.mysql." + otherTable + "DAO");
					AbstractDAO<?> daoAux = (AbstractDAO<?>) klass.getMethod("getInstance", new Class[]{}).invoke(null, new Object[]{});
					
					Object result = daoAux.getByAttributes(search).get(0);
					
					field.set(object, result);
					
				} catch (IllegalAccessException | NoSuchFieldException | SecurityException | ClassNotFoundException | NoSuchMethodException | IllegalArgumentException | InvocationTargetException | SQLException e) {
					e.printStackTrace();
				}				
			}
		}
	}

	private void loadManyRelationships(T object) {
		for (Field field: className.getFields()) {			
			DBCollection dbc = field.getAnnotation(DBCollection.class);
										
			if (dbc != null) {
				try {
					Class<?> dbcClass = dbc.klass();
					HashMap<String, Object> search = new HashMap<String, Object>();
					
					for (int i = 0; i < dbc.thisPk().length; i++) {					
						Field fieldThis = object.getClass().getDeclaredField(dbc.thisPk()[i]);
						
						fieldThis.setAccessible(true);
						Object value = fieldThis.get(object);
						fieldThis.setAccessible(false);
						
						search.put(dbc.fk()[i], value);
					}					
					Class<?> klass = Class.forName("dal.concrete.mysql." + dbcClass.getSimpleName() + "DAO");
					AbstractDAO<?> daoAux = (AbstractDAO<?>) klass.getMethod("getInstance", new Class[]{}).invoke(null, new Object[]{});
					
					Object result = daoAux.getByAttributes(search);
					
					
					field.set(object, result);
					
				} catch (IllegalAccessException | NoSuchFieldException | SecurityException | ClassNotFoundException | NoSuchMethodException | IllegalArgumentException | InvocationTargetException | SQLException e) {
					e.printStackTrace();
				}				
			}
		}
	}

	private void loadOneRelationships(T object) {
		for (Field field: className.getFields()) {			
			ForeignKey fk = field.getAnnotation(ForeignKey.class);
						
			if (fk != null) {
				try {
					Class<?> fkClass = field.getType();
					
					HashMap<String, Object> search = new HashMap<String, Object>();
					
					for (int i = 0; i < fk.thisSideAttrs().length; i++) {					
						Field fieldThis = object.getClass().getDeclaredField(fk.thisSideAttrs()[i]);
						
						fieldThis.setAccessible(true);
						Object value = fieldThis.get(object);
						fieldThis.setAccessible(false);
						
						search.put(fk.otherSideAttrs()[i], value);
					}
									
					Class<?> klass = Class.forName("dal.concrete.mysql." + fkClass.getSimpleName() + "DAO");
					AbstractDAO<?> daoAux = (AbstractDAO<?>) klass.getMethod("getInstance", new Class[]{}).invoke(null, new Object[]{});
					
					Object result = daoAux.getByAttributes(search).get(0);
					
					
					field.set(object, result);
					
				} catch (IllegalAccessException | NoSuchFieldException | SecurityException | ClassNotFoundException | NoSuchMethodException | IllegalArgumentException | InvocationTargetException | SQLException e) {
					e.printStackTrace();
				}				
			}
		}
	}

	public T getByPk(T object) throws SQLException, ClassNotFoundException {
		Connection conn = ConnectionManager.getConnection();
		ArrayList<T> result = new ArrayList<T>();
		
		Statement statement = null;
        
        statement = conn.createStatement();
        
        String queryString = "Select * from " + getTableName() + " where " + generateCompareString(object, true);
        
        System.out.println(queryString);
               
        ResultSet rs = statement.executeQuery(queryString);
        
		try {
			while (rs.next()) {
				T obj = (T) className.newInstance();
	
				for (Field field : className.getFields()) {
					Column col = field.getAnnotation(Column.class);
	
					if (col != null) {
						
						field.set(obj, rs.getObject(col.columnName()));
						
					}
				}
				
				result.add(obj);
			}
		} catch (InstantiationException e){
			e.printStackTrace();
		}		
		catch (IllegalAccessException e) {
			e.printStackTrace();
		}
        
        rs.close();
        
        return result.get(0);
	}
	
	public List<T> getByAttributes(HashMap<String, Object> attrs) throws SQLException, ClassNotFoundException {
		Connection conn = ConnectionManager.getConnection();
		ArrayList<T> result = new ArrayList<T>();
		
		Statement statement = null;
        
        statement = conn.createStatement();
        
        String queryString = "Select * from " + getTableName() + " where " + generateCompareString(attrs);
        
        System.out.println(queryString);
               
        ResultSet rs = statement.executeQuery(queryString);
        
		try {
			while (rs.next()) {
				T obj = (T) className.newInstance();
	
				for (Field field : className.getFields()) {
					Column col = field.getAnnotation(Column.class);
	
					if (col != null) {
						
						field.set(obj, rs.getObject(col.columnName()));
						
					}
				}
				
				result.add(obj);
			}
		} catch (InstantiationException e){
			e.printStackTrace();
		}		
		catch (IllegalAccessException e) {
			e.printStackTrace();
		}
        
        rs.close();
        
        return result;
	}
	
	private String generateCompareString(T newObject, boolean onlyPk) {
		StringBuilder builder = new StringBuilder();
				
		String prefix = "";
		for (Field field: className.getFields()) {			
			Column col = field.getAnnotation(Column.class);
			
			if (col != null) {
				if (onlyPk && !col.pk())
					continue;
				
				try {
					builder.append(prefix);
					prefix = " and ";
					
					Object obj = field.get(newObject);
					
					builder.append(col.columnName() + "=");
					
					if (field.getType() == String.class || field.getType() == Timestamp.class)
						builder.append("'");
					
					builder.append(obj.toString());
					
					if (field.getType() == String.class || field.getType() == Timestamp.class)
						builder.append("'");
					
				} catch (IllegalArgumentException e) {
					e.printStackTrace();
				} catch (IllegalAccessException e) {
					e.printStackTrace();
				}
			}
		}
						
		return builder.toString();	
	}
	
	private String generateCompareString(HashMap<String, Object> attrs) {
		StringBuilder builder = new StringBuilder();
		
		String prefix = "";
		for (Field field: className.getFields()) {			
			Column col = field.getAnnotation(Column.class);
						
			if (col != null) {
				try {
					Object obj = attrs.get(field.getName());
					
					if (obj == null)
						continue;
					
					builder.append(prefix);
					prefix = " and ";
					
					builder.append(col.columnName() + "=");
					
					if (field.getType() == String.class || field.getType() == Timestamp.class)
						builder.append("'");
					
					builder.append(obj.toString());
					
					if (field.getType() == String.class || field.getType() == Timestamp.class)
						builder.append("'");
					
				} catch (IllegalArgumentException e) {
					e.printStackTrace();
				}
			}
		}
						
		return builder.toString();
	}

	public void create(T object) throws ClassNotFoundException, SQLException {
		Connection conn = ConnectionManager.getConnection();
		
		Statement statement = null;
        int updateQuery = 0;
        
        statement = conn.createStatement();
        
        String queryString = "Insert into " + getTableName() + " " + createAttributesString() + " values " + createStringToAdd(object);
        System.out.println(queryString);                
        
        updateQuery = statement.executeUpdate(queryString);
        
        if (updateQuery != 0) {
        	System.out.println("Hue");
        }
	}
	
	public List<T> getAll() throws ClassNotFoundException, SQLException {
		Connection conn = ConnectionManager.getConnection();
		ArrayList<T> result = new ArrayList<T>();
		
		Statement statement = null;
        
        statement = conn.createStatement();
        
        String queryString = "Select * from " + getTableName();
               
        ResultSet rs = statement.executeQuery(queryString);
        
        while (rs.next()) {
        	try {
				T obj = (T) className.newInstance();
				
	            for (Field field: className.getFields()) {			
	    			Column col = field.getAnnotation(Column.class);
	    			
	    			if (col != null) {
	    				
	    				field.set(obj, rs.getObject(col.columnName()));
	    				
	    			}
	    		}
	            
	            result.add(obj);
			} catch (InstantiationException e){
				e.printStackTrace();
			}catch(IllegalAccessException e) {
				e.printStackTrace();
			}
        }
        
        rs.close();
        
        return result;
    }

	public void update(T newObject) throws ClassNotFoundException, SQLException {
		Connection conn = ConnectionManager.getConnection();
		
		Statement statement = null;
        int updateQuery = 0;
        
        statement = conn.createStatement();
        
        String queryString = "Update " + getTableName() + " set " + updateStringToAdd(newObject) 
        	+ " where " + generateCompareString(newObject, true);
        System.out.println(queryString);            
        
        updateQuery = statement.executeUpdate(queryString);
        
        if (updateQuery != 0) {
        	System.out.println("Hue");
        }
	}
	
	public void update(T oldObject, T newObject) throws ClassNotFoundException, SQLException {
		Connection conn = ConnectionManager.getConnection();
		
		Statement statement = null;
        int updateQuery = 0;
        
        statement = conn.createStatement();
        
        String queryString = "Update " + getTableName() + " set " + updateStringToAdd(newObject) 
        	+ " where " + generateCompareString(oldObject, false);
        System.out.println(queryString);            
        
        updateQuery = statement.executeUpdate(queryString);
        
        if (updateQuery != 0) {
        	System.out.println("Hue");
        }
	}

	private String updateStringToAdd(T newObject) {
		StringBuilder builder = new StringBuilder();
				
		String prefix = "";
		for (Field field: className.getFields()) {			
			Column col = field.getAnnotation(Column.class);
			
			if (col != null) {
				if (col.autoGenerated())
					continue;
				
				try {
					builder.append(prefix);
					prefix = " , ";
					
					Object obj = field.get(newObject);		
					
					builder.append(col.columnName() + "=");
					
					if (field.getType() == String.class || field.getType() == Timestamp.class)
						builder.append("'");
					
					builder.append(obj.toString());
					
					if (field.getType() == String.class || field.getType() == Timestamp.class)
						builder.append("'");
					
				} catch (IllegalArgumentException e) {
					e.printStackTrace();
				} catch (IllegalAccessException e) {
					e.printStackTrace();
				}
			}
		}
				
		return builder.toString();	
	}

	public void delete(T object) throws ClassNotFoundException, SQLException {
		Connection conn = ConnectionManager.getConnection();
		
		Statement statement = null;
        int updateQuery = 0;
        
        statement = conn.createStatement();
        
        String queryString = "Delete from " + getTableName() + " where " + generateCompareString(object, false);
        System.out.println(queryString);            
        
        updateQuery = statement.executeUpdate(queryString);
        
        if (updateQuery != 0) {
        	System.out.println("Hue");
        }
	}
	
	public void deleteByPk(T object) throws ClassNotFoundException, SQLException {
		Connection conn = ConnectionManager.getConnection();
		
		Statement statement = null;
        int updateQuery = 0;
        
        statement = conn.createStatement();
        
        String queryString = "Delete from " + getTableName() + " where " + generateCompareString(object, true);
        System.out.println(queryString);            
        
        updateQuery = statement.executeUpdate(queryString);
        
        if (updateQuery != 0) {
        	System.out.println("Hue");
        }
	}
	
	public void deleteAll() throws ClassNotFoundException, SQLException {
		Connection conn = ConnectionManager.getConnection();
		
		Statement statement = null;
        int updateQuery = 0;
        
        statement = conn.createStatement();
        
        String queryString = "Delete from " + getTableName();
        System.out.println(queryString);            
        
        updateQuery = statement.executeUpdate(queryString);
        
        if (updateQuery != 0) {
        	System.out.println("Hue");
        }
	}
}

